1. 	<문제 해설>
MOM(Message Oriented Middleware)
- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
[해설작성자 : 두목넷]

MOM(Message Oriented Middleware)은 ﻿즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용됩니다.
[해설작성자 : 세유니에용]

2.
익스트림 프로그래밍에 대한 설명으로 틀린 것은?
     
     1.	대표적인 구조적 방법론 중 하나이다.
     2.	소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
     3.	익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.
     4.	구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다.

     입력한 답 : 4
     정답 : [1] 
     정답률 : 63%
     	<문제 해설>
1. 구조적 방법론이 아니라 애자일 방법론 중 하나이다.
[해설작성자 : 지나가는 행인]

구조적 방법론은 계획 중심의 접근 방식을 따르는 반면, 익스트림 프로그래밍은 반복적이고 점진적인 개발을 강조하여 변화에 유연하게 대응할 수 있도록 설계된 방법론으로 차이가 있다.
[해설작성자 : 노작가]


3.
유스케이스(Use Case)의 구성 요소 간의 관계
- 연관관계(Association) :  유스케이스와 액터간의 상호작용이 있음을 표현한다.
- 포함 관계(Include): 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계이다.
- 확장 관계(Extend):  확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성 되는 관계이다.
- 일반화 관계(Generalization) : 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계이다

4.
	<문제 해설>
기능적 요구사항 Vs 비기능적 요구사항
- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 성능, 보안, 품질, 안정성등으로 실제 수행에 보조적인 요구사항
오답피하기
- 차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다' 는 성능에 해당 하므로 비기능적 요구사항에 해당한다.
[해설작성자 : 두목넷]

5. 인터페이스
소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어, 순서적 연산에의해 소프트웨어를 실행하는 절차

6.
	<문제 해설>
클래스: 하나 이상의 유사한 객체들을 묶는다.
캡슐화: 서로 관련성이 많은 데이터들과 연산들을 묶는다.
[해설작성자 : comcbt.com 이용자]

상속(Inheritance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
클래스: 하나 이상의 유사한 객체들을 묶는다.
캡슐화(Encapsulation): 서로 관련성이 많은 데이터들과 연산들을 묶는다.
연관관계 (Association) : 2개 이상의 사물이 서로 관련되어 있음을 표현한다
[해설작성자 : comcbt.com 이용자]
[해설작성자 : 박지인]

Encapsulation -> 인캡슐 -> 캡슐 안에 넣다 -> 클래스 안에 속성과 연산들을 묶어서 넣는다.
이렇게 이해하면 쉽다.
[해설작성자 : 선택결과]

7.제어(controller)는 뷰(view)와 모델(model)사이에서 전달자 역할을 수행한다.

8. 	<문제 해설>
워크스루: 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견
인스펙션: 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견.

9.
화이트박스 테스트는 정적 분석뿐만 아니라 동적 분석에도 사용될 수 있습니다. 정적 분석에서는 코드를 실행하지 않고 검토하여 문제점을 찾지만, 동적 분석에서는 실제로 코드를 실행시켜 테스트를 진행합니다. 화이트박스 테스트의 경우, 프로그램의 내부 구조를 알고 있는 상태에서 테스트를 진행하기 때문에, 로직 흐름도를 이용하여 로직 검증을 할 수 있고, 
동적 테스트를 통해 실제 실행 중인 프로그램의 동작을 검증할 수도 있습니다.
제시된 문제에서 언급된 "프로그램의 구조를 고려하지 않고 때때로 테스트 케이스는 프로그램 코드 또는 모듈의 우연한 면을 기준으로 결정한다"는 주장은 화이트박스 테스트에 부합하지 않습니다. 화이트박스 테스트는 프로그램의 내부 구조에 기반하여 체계적으로 테스트 케이스를 설계하기 때문에 우연한 면을 기준으로 테스트 케이스를 설계하지 않습니다.

10. 	<문제 해설>
선형 검색 - 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색
[해설작성자 : 전자공학도]

이진검색 - 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.
[해설작성자 : 문은식]

11. 단위 테스트(Unit Test)
필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(test driver)라고 한다. 
반대로 테스트 스텁(test stub)은 인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할을 한다.

12. 노드ㅡ탐색
전위 운행 (PreOrder) => Root, Left, Right 순서
중위 운행 (InOrder) => Left, Root, Right 순서
후위 운행 (PostOrder) => Left, Right, Root 순서
[해설작성자 : Eclatz]

pre_order (전위순회) : 뿌리 먼저 방문
in_order (중위순회) : 왼쪽 하위 노드 방문 후 뿌리 방문
post_order (후위순회) : 하위 노드 모두 방문 후 뿌리 방문
[해설작성자 : 트리맨]

13.
1. Stack = LIFO, 한 쪽 끝에서 일어남
2. Queue = FIFO, 양방향에서 일어남
3. Tree & Graph 는 비선형구조

14.
	<문제 해설>
CppUnit - C++ 프로그래밍 언어용 단위 테스트 도구
JUnit - 자바 프로그래밍 언어용 단위 테스트 도구
[해설작성자 : comcbt.com 이용자]

HttpUnit - 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크 입니다.
[해설작성자 : 상동닭집]

IgpUnit은 존재하지 않는 유닛입니다.
[해설작성자 : 왕재수]

15.
트랜잭션의 특성
- 원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함
- 일관성(Consistency) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함
- 격리성(Isolation, 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
- 영속성(Durability, 지속성) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨
[해설작성자 : 두목넷]

16.
	<문제 해설>
저장 레코드 양식 설계 시 고려 사항
- 데이터 타입, 데이터 값의 분포, 접근 빈도
오답피하기 | 트랜잭션 모델링
- 트랜잭션을 개념적 시스템 독립적으로 정의한다.
- 트랜잭션의 입출력 기능, 형태만 정의한다.
- 검색, 갱신, 혼합(검색, 갱신)
[해설작성자 : 두목넷 ]

3번 보기 트랜잭션 모델링은 개념적 설계 단계에서 하는것
[해설작성자 : ㅇㅅㅊ]

17.
Partially Committed: 마지막 연산이 실행된 직후의 상태로 아직 Commit 연산 실행 전
Committed: 트랜잭션이 실행을 성공적으로 완료하여 Commit 연산을 수행한 상태
[해설작성자 : 칼방이]

        ->    partially committed  -> committed
active |           |
       |           V
        ->       failed            -> aborted(rollback연산)
[해설작성자 : comcbt.com 이용자]

18. C언어 문자열 처리 함수
	<문제 해설>
strcat - 문자열 연결 함수
[해설작성자 : 수도공고갤러리 갤주]

strcmp - 문자열 비교
[해설작성자 : comcbt.com 이용자]

함수명에 용고를 의미하는 약어가 포함되어 있음
str -> string
len -> length
cpy -> copy
cmp -> compare
rev -> reverse
[해설작성자 : Jinni]


19.
	<문제 해설>
a && b -> 1      AND연산
a || b -> 1      OR연산
!c -> 0          NOT연산
1 + 1 + 0 = 2 (최종정답)
# C언어 연산자에서는 0이 아닌 모든값은 1(TRUE)로 본다.
그래서 a=1 b=1 c=1 로 바꿔서 대입해도 같은결과가 나온다
[해설작성자 : 루니]

Int a,b,c에 정의된 값들을 조건절에 대입.
t1= 1&&2 *&&는 좌우가 모두 참이여야 함, 좌우에 모든 값이 존재함으로 1=참
t2=1||2 *||는 좌우 중 1개만 참이어도 참, 좌우 모든 값이 존재함으로 1=참
t3=!c *!는 NOT연산으로 3의 값이 없음을 말하기에 0=거짓
그래서 1+1+0 =2
[해설작성자 : 사람]

20.

struct st{
  int a;
int c[10];
};

int main (int argc, char *argv[]) {
  int i =0;
  struct st ob1;
  struct st 0b2;
  ob1.a=0;
  ob2.a=0;

  for(i=0; i<10; i++ {
        ob1.c[i] = i;
        ob2.c[i]=ob1.c[i] + i;
  }

  for(i=0; i <10; i = i+2) {
      ob1.a = ob1.a + ob1.c[i];
      ob2.a = ob2.a + ob2.c[i];
  }

  printf("%d", ob1.a + ob2.a);



<문제 해설>
ob1.c[i] = i
ob2.c[i] = i + i
ob1.a = ob1.a + ob1.c[i]  =  0+2+4+6 + 8  = 20
ob2.a = ob2.a + ob2.c[i]  =  0+4+8+12+16 = 40
20 + 40 = 60
[해설작성자 : 루니]

int a와 int c[10]에 따라 아래처럼 생성.
ob1 a=0
    c=(10칸)
ob2 a=0
    c=(10칸)
이후 for를 따라서 ob1,2의 c칸들을 채움.
*ob1.c[I]=i (0부터 9까지 쭉 채운다.)
*ob2.c[I]=ob1.c[i]+i (ob1의 c의 자리값과 i의 값을 더해서 생성.)
**더하다 보면 알겠지만 ob2.c는 2씩 증가함.
그러면 아래의 값이 나온다.
ob1 a=0
    c= 0 1 2 3 4 5 6 7 9
ob2 a=0
    c=0 2 4 6 8 10 12 14 16 18
이후 두번째 for를 따라서 a의 값을 구하자.
ob1.a=ob1.a+ob1.c[i]
*ob1.a의 기존 값과 ob2.c의 자리 숫자를 더해서 ob1.a에 넣어라.
ex.
i가 0일 경우, 기존 ob1.a인 0과 ob1.c의 0번째인 0을 더하면 0+0=0
ob1 a=0
    c=0 1 2 3 4 5 6 7 9
i가 2일 경우, 기존  ob1.a인 0과 ob1.c의 2번째인 2을 더하면 0+2=2
ob1 a=2
    c=0 1 2 3 4 5 6 7 9
이런식으로 ob1과 ob2를 쭉 구해주면 아래의 식이 나온다.
ob1 a=24
    c=0 1 2 3 4 5 6 7 9
ob2 a=40
    c=0 2 4 6 8 10 12 14 16 18
이후 ob1.a+ob2.a에 맞춰 더하면
24+40으로, 60이 출력된다.
[해설작성자 : 이거라도 맞춰야지]

아래와 같은 오류 신고가 있었습니다.
여러분들의 많은 의견 부탁 드립니다.
추후 여러분들의 의견을 반영하여 정답을 수정하도록 하겠습니다.
참고로 정답 변경은 오류 신고 5회 이상일 경우 수정합니다.

[오류 신고 내용]
위에 해설 설명은 맞는데 값이 다름.
ob1.a의 값 오타인 듯?
ob1.a=0>0>2>6>12>20 이렇게 변함.
[해설작성자 : 꼼수]

[오류신고 반론]
a랑 b는 리스트

i 가 0일 때
a[0]=0
b[0]=0

i 가 1일 때
a[1]=1
b[1]=2 (a[1]=1에 i=1를 더한거 1+1=2)

i 가 2일 때
a[2]=2
b[2]=4 (a[2]=2에 i=2 더하면 2+2=4)

b[i]는 a[i]에다가 곱하기 2하면 됨

…..
프린트할 거는 밑에 꺼니까
구하는 값은 A랑 B 더한 거
A랑 B는 변수
누적하는 거

i가 2씩 증가하고 10 전까지니까
i 에 0 2 4 6 8 넣어보면 됨
A랑 B는 초기값 0

i=0 일 때
A= 0+ a[0]=0       #A=0
B= 0+ b[0]=0      #B=0

i=2 일 때
A’ =0+ a[2]=2        #A’=2
B’ =0+ b[2]=4        #B’=4

i 가 4일 때
A” =2+ a[4]=4        #A”=6
B” =4+ b[4]=8       #B”=12

i가 6일 때
A’” =6+ a[6]=6       #A’”=12
B’”=12+ b[6]=12     #B’”=24

i가 8일 때
A””=12+a[8]=8       #A””=20
B””=24+b[8]=16     #B””=40

A””+B””=60
[해설작성자 : 노노나나]


