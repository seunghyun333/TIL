1. 	<문제 해설>
MOM(Message Oriented Middleware)
- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
[해설작성자 : 두목넷]

MOM(Message Oriented Middleware)은 ﻿즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용됩니다.
[해설작성자 : 세유니에용]

2.
익스트림 프로그래밍에 대한 설명으로 틀린 것은?
     
     1.	대표적인 구조적 방법론 중 하나이다.
     2.	소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
     3.	익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.
     4.	구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다.

     입력한 답 : 4
     정답 : [1] 
     정답률 : 63%
     	<문제 해설>
1. 구조적 방법론이 아니라 애자일 방법론 중 하나이다.
[해설작성자 : 지나가는 행인]

구조적 방법론은 계획 중심의 접근 방식을 따르는 반면, 익스트림 프로그래밍은 반복적이고 점진적인 개발을 강조하여 변화에 유연하게 대응할 수 있도록 설계된 방법론으로 차이가 있다.
[해설작성자 : 노작가]


3.
유스케이스(Use Case)의 구성 요소 간의 관계
- 연관관계(Association) :  유스케이스와 액터간의 상호작용이 있음을 표현한다.
- 포함 관계(Include): 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계이다.
- 확장 관계(Extend):  확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성 되는 관계이다.
- 일반화 관계(Generalization) : 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계이다

4.
	<문제 해설>
기능적 요구사항 Vs 비기능적 요구사항
- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 성능, 보안, 품질, 안정성등으로 실제 수행에 보조적인 요구사항
오답피하기
- 차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다' 는 성능에 해당 하므로 비기능적 요구사항에 해당한다.
[해설작성자 : 두목넷]

5. 인터페이스
소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어, 순서적 연산에의해 소프트웨어를 실행하는 절차

6.
	<문제 해설>
클래스: 하나 이상의 유사한 객체들을 묶는다.
캡슐화: 서로 관련성이 많은 데이터들과 연산들을 묶는다.
[해설작성자 : comcbt.com 이용자]

상속(Inheritance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
클래스: 하나 이상의 유사한 객체들을 묶는다.
캡슐화(Encapsulation): 서로 관련성이 많은 데이터들과 연산들을 묶는다.
연관관계 (Association) : 2개 이상의 사물이 서로 관련되어 있음을 표현한다
[해설작성자 : comcbt.com 이용자]
[해설작성자 : 박지인]

Encapsulation -> 인캡슐 -> 캡슐 안에 넣다 -> 클래스 안에 속성과 연산들을 묶어서 넣는다.
이렇게 이해하면 쉽다.
[해설작성자 : 선택결과]

7.제어(controller)는 뷰(view)와 모델(model)사이에서 전달자 역할을 수행한다.

8. 	<문제 해설>
워크스루: 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견
인스펙션: 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견.

9.
화이트박스 테스트는 정적 분석뿐만 아니라 동적 분석에도 사용될 수 있습니다. 정적 분석에서는 코드를 실행하지 않고 검토하여 문제점을 찾지만, 동적 분석에서는 실제로 코드를 실행시켜 테스트를 진행합니다. 화이트박스 테스트의 경우, 프로그램의 내부 구조를 알고 있는 상태에서 테스트를 진행하기 때문에, 로직 흐름도를 이용하여 로직 검증을 할 수 있고, 
동적 테스트를 통해 실제 실행 중인 프로그램의 동작을 검증할 수도 있습니다.
제시된 문제에서 언급된 "프로그램의 구조를 고려하지 않고 때때로 테스트 케이스는 프로그램 코드 또는 모듈의 우연한 면을 기준으로 결정한다"는 주장은 화이트박스 테스트에 부합하지 않습니다. 화이트박스 테스트는 프로그램의 내부 구조에 기반하여 체계적으로 테스트 케이스를 설계하기 때문에 우연한 면을 기준으로 테스트 케이스를 설계하지 않습니다.

10. 	<문제 해설>
선형 검색 - 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색
[해설작성자 : 전자공학도]

이진검색 - 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.
[해설작성자 : 문은식]

11. 단위 테스트(Unit Test)
필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(test driver)라고 한다. 
반대로 테스트 스텁(test stub)은 인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할을 한다.

12. 노드ㅡ탐색
전위 운행 (PreOrder) => Root, Left, Right 순서
중위 운행 (InOrder) => Left, Root, Right 순서
후위 운행 (PostOrder) => Left, Right, Root 순서
[해설작성자 : Eclatz]

pre_order (전위순회) : 뿌리 먼저 방문
in_order (중위순회) : 왼쪽 하위 노드 방문 후 뿌리 방문
post_order (후위순회) : 하위 노드 모두 방문 후 뿌리 방문
[해설작성자 : 트리맨]

13.
1. Stack = LIFO, 한 쪽 끝에서 일어남
2. Queue = FIFO, 양방향에서 일어남
3. Tree & Graph 는 비선형구조

14.
	<문제 해설>
CppUnit - C++ 프로그래밍 언어용 단위 테스트 도구
JUnit - 자바 프로그래밍 언어용 단위 테스트 도구
[해설작성자 : comcbt.com 이용자]

HttpUnit - 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크 입니다.
[해설작성자 : 상동닭집]

IgpUnit은 존재하지 않는 유닛입니다.
[해설작성자 : 왕재수]

15.
트랜잭션의 특성
- 원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함
- 일관성(Consistency) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함
- 격리성(Isolation, 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
- 영속성(Durability, 지속성) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨
[해설작성자 : 두목넷]

16.
	<문제 해설>
저장 레코드 양식 설계 시 고려 사항
- 데이터 타입, 데이터 값의 분포, 접근 빈도
오답피하기 | 트랜잭션 모델링
- 트랜잭션을 개념적 시스템 독립적으로 정의한다.
- 트랜잭션의 입출력 기능, 형태만 정의한다.
- 검색, 갱신, 혼합(검색, 갱신)
[해설작성자 : 두목넷 ]

3번 보기 트랜잭션 모델링은 개념적 설계 단계에서 하는것
[해설작성자 : ㅇㅅㅊ]

17.
Partially Committed: 마지막 연산이 실행된 직후의 상태로 아직 Commit 연산 실행 전
Committed: 트랜잭션이 실행을 성공적으로 완료하여 Commit 연산을 수행한 상태
[해설작성자 : 칼방이]

        ->    partially committed  -> committed
active |           |
       |           V
        ->       failed            -> aborted(rollback연산)
[해설작성자 : comcbt.com 이용자]

18. C언어 문자열 처리 함수
	<문제 해설>
strcat - 문자열 연결 함수
[해설작성자 : 수도공고갤러리 갤주]

strcmp - 문자열 비교
[해설작성자 : comcbt.com 이용자]

함수명에 용고를 의미하는 약어가 포함되어 있음
str -> string
len -> length
cpy -> copy
cmp -> compare
rev -> reverse
[해설작성자 : Jinni]


19.
	<문제 해설>
a && b -> 1      AND연산
a || b -> 1      OR연산
!c -> 0          NOT연산
1 + 1 + 0 = 2 (최종정답)
# C언어 연산자에서는 0이 아닌 모든값은 1(TRUE)로 본다.
그래서 a=1 b=1 c=1 로 바꿔서 대입해도 같은결과가 나온다
[해설작성자 : 루니]

Int a,b,c에 정의된 값들을 조건절에 대입.
t1= 1&&2 *&&는 좌우가 모두 참이여야 함, 좌우에 모든 값이 존재함으로 1=참
t2=1||2 *||는 좌우 중 1개만 참이어도 참, 좌우 모든 값이 존재함으로 1=참
t3=!c *!는 NOT연산으로 3의 값이 없음을 말하기에 0=거짓
그래서 1+1+0 =2
[해설작성자 : 사람]

20.

struct st{
  int a;
int c[10];
};

int main (int argc, char *argv[]) {
  int i =0;
  struct st ob1;
  struct st 0b2;
  ob1.a=0;
  ob2.a=0;

  for(i=0; i<10; i++ {
        ob1.c[i] = i;
        ob2.c[i]=ob1.c[i] + i;
  }

  for(i=0; i <10; i = i+2) {
      ob1.a = ob1.a + ob1.c[i];
      ob2.a = ob2.a + ob2.c[i];
  }

  printf("%d", ob1.a + ob2.a);
  return 0;
}



<문제 해설>
ob1.c[i] = i
ob2.c[i] = i + i
ob1.a = ob1.a + ob1.c[i]  =  0+2+4+6 + 8  = 20
ob2.a = ob2.a + ob2.c[i]  =  0+4+8+12+16 = 40
20 + 40 = 60
[해설작성자 : 루니]

int a와 int c[10]에 따라 아래처럼 생성.
ob1 a=0
    c=(10칸)
ob2 a=0
    c=(10칸)
이후 for를 따라서 ob1,2의 c칸들을 채움.
*ob1.c[I]=i (0부터 9까지 쭉 채운다.)
*ob2.c[I]=ob1.c[i]+i (ob1의 c의 자리값과 i의 값을 더해서 생성.)
**더하다 보면 알겠지만 ob2.c는 2씩 증가함.
그러면 아래의 값이 나온다.
ob1 a=0
    c= 0 1 2 3 4 5 6 7 9
ob2 a=0
    c=0 2 4 6 8 10 12 14 16 18
이후 두번째 for를 따라서 a의 값을 구하자.
ob1.a=ob1.a+ob1.c[i]
*ob1.a의 기존 값과 ob2.c의 자리 숫자를 더해서 ob1.a에 넣어라.
ex.
i가 0일 경우, 기존 ob1.a인 0과 ob1.c의 0번째인 0을 더하면 0+0=0
ob1 a=0
    c=0 1 2 3 4 5 6 7 9
i가 2일 경우, 기존  ob1.a인 0과 ob1.c의 2번째인 2을 더하면 0+2=2
ob1 a=2
    c=0 1 2 3 4 5 6 7 9
이런식으로 ob1과 ob2를 쭉 구해주면 아래의 식이 나온다.
ob1 a=24
    c=0 1 2 3 4 5 6 7 9
ob2 a=40
    c=0 2 4 6 8 10 12 14 16 18
이후 ob1.a+ob2.a에 맞춰 더하면
24+40으로, 60이 출력된다.
[해설작성자 : 이거라도 맞춰야지]

아래와 같은 오류 신고가 있었습니다.
여러분들의 많은 의견 부탁 드립니다.
추후 여러분들의 의견을 반영하여 정답을 수정하도록 하겠습니다.
참고로 정답 변경은 오류 신고 5회 이상일 경우 수정합니다.

[오류 신고 내용]
위에 해설 설명은 맞는데 값이 다름.
ob1.a의 값 오타인 듯?
ob1.a=0>0>2>6>12>20 이렇게 변함.
[해설작성자 : 꼼수]

[오류신고 반론]
a랑 b는 리스트

i 가 0일 때
a[0]=0
b[0]=0

i 가 1일 때
a[1]=1
b[1]=2 (a[1]=1에 i=1를 더한거 1+1=2)

i 가 2일 때
a[2]=2
b[2]=4 (a[2]=2에 i=2 더하면 2+2=4)

b[i]는 a[i]에다가 곱하기 2하면 됨

…..
프린트할 거는 밑에 꺼니까
구하는 값은 A랑 B 더한 거
A랑 B는 변수
누적하는 거

i가 2씩 증가하고 10 전까지니까
i 에 0 2 4 6 8 넣어보면 됨
A랑 B는 초기값 0

i=0 일 때
A= 0+ a[0]=0       #A=0
B= 0+ b[0]=0      #B=0

i=2 일 때
A’ =0+ a[2]=2        #A’=2
B’ =0+ b[2]=4        #B’=4

i 가 4일 때
A” =2+ a[4]=4        #A”=6
B” =4+ b[4]=8       #B”=12

i가 6일 때
A’” =6+ a[6]=6       #A’”=12
B’”=12+ b[6]=12     #B’”=24

i가 8일 때
A””=12+a[8]=8       #A””=20
B””=24+b[8]=16     #B””=40

A””+B””=60
[해설작성자 : 노노나나]


21.
IP 프로토콜에서 사용하는 필드와 해당 필드에 대한 설명으로 틀린 것은?
     
     1.	Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
     2.	Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.
     3.	Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
     4.	Version Number는 IP 프로토콜의 버전번호를 나타낸다.

     입력한 답 : 1
     정답 : [2] 
     정답률 : 52%
     	<문제 해설>
Total Packet Length (16 bits): IP 헤더 및 데이터를 포함한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시. (최대값은 65,535 = 2^16 - 1)
[해설작성자 : 루니]

22.
	<문제 해설>
RIP(Routing Information Protocol)
- 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
- 최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.
- 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.
- 소규모 네트워크 환경에 적합하다.
- 최대 홉 카운트를 15홉 이하로 한정하고 있다.
[해설작성자 : 두목넷]

보기 2번 추가 내용 :)
* 자율 시스템(AS : Autonomous System)
- 하나의 기관 내부를 나타내는 것으로 라우터들과 통신기기들의 집합. 예를 들면 하나의 학내망
* IGP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜)
- 학내망 내부에서 라우팅하는것. 즉 하나의 AS 내에서의 라우팅에 사용되는 프로토콜
* EGP(Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)
- 학내망과 다른 학내망의 라우팅에 사용. 즉 AS간의 라우팅에 사용되는 프로토콜
RIP는 OSPF와 함께 IGP(내부 게이트웨이 프로토콜)에 해당한다

23.
Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?
리스트 타입 : 가변형
튜플 타입 : 불변형

시퀀스- 리스트 - 순서있고,가변 [1,2,3]
시퀀스- 튜플   - 순서있고,불변 (1,2,3)
세트  - 세트   - 순서없고,중복x {1,2,3}
맵    - 딕셔너리- 순서없고,key-value쌍 {'a':1,'b:2,'c':3}

24. C언어
int n1= 1, n2=2, n3=3;
int r1, r2, r3;

r1=(n2<=2) || (n3>3);
r2=!n3;
r3=(n1>1) && (n2<3);

prinf("%d", r3-r2+1);
return 0;

	<문제 해설>
r1 - or 연산 한쪽만 참이여도 1 반환 n2<=2(참) -> 1
r2 - =! 부정연산자 3 부정 0 반환 -> 0
r3 - and 연산 둘다 참이여야 1반환 (n1>1) (거짓) -> 0
0 - 0 + 1 = 1


25.
LRU 페이지 교체 알고리즘 공부하기,, 

26.
스탬프 결합도 - 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.
내용 결합도 - 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.
공통 결합도 -  두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어 있다고 한다.
결합도 -  두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것이다

내용 결합도
-하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있는 경우의 결합도
TIP : 쏼라 쏼라~  내용 참조, 자료 참조 (단어가 있으면)  내용 결합도


27. C언어
int main(int argc, char *argv[]) {
	int a[] = {14, 22, 30, 38} ;
	printf("%u,", &a[2];
	printf("%u", a);
	return 0;
}

<문제 해설>
      {14           ,22,          30,           38         }
주소값 10,11,12,13 / 14,15,16,17 / 18,19,20,21 / 22,23,24,25
자리값 a(0)           a(1)         a(2)          a(3)
*1개의 주소값 : 1Byte

printf("%u, ", &a[2];      a[2]자리의 첫번째 주소값   18
printf("%u", a);           a[0]자리의 첫번째 주소값   10
[해설작성자 : 루니]

배열은 자료형이 같은 변수를 메모리에 연속으로 할당합니다.
int형인 배열 요소 14, 22, 30, 38은 제시된 문제에 따라 메모리 10번지부터 시작하여 4바이트 간격으로 각각 10, 14, 18, 22번지의 주소값을 할당 받습니다.
%u <--- 부호 없는 10진수로 출력하는 변환 문자입니다.
printf("%u, ", &a[2]); <--- &a[2]는 &a + 2 또는 10 + (2 * sizeof(int)) 이며 18입니다. 18번지부터 21번지까지의 총 4바이트 저장 공간인 주소 값을 뜻합니다.
printf("%u", a); <--- 배열명은 첫 번째 배열 요소(a[0])의 주소값 입니다.
“%u, "에는 쉼표와 띄어쓰기가 있으므로 실행 결과는 18, 10 입니다.

28.
1.Worm: 악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식
2. Rogue Ware(Rogue security software; 가짜 백신 소프트웨어) : 사용자가 컴퓨터에 바이러스가 있다고 잘못 믿게 하고 컴퓨터에 실제로 악성 프로그램을 설치토록 하거나, 가짜 악성 프로그램 제거 도구에 대한 비용을 지불하도록 설득함. 공포심을 통해 사용자를 조종
3.Adware : 특정 소프트웨어를 실행할 때 또는 자동으로 활성화되는 광고프로그램으로 이 자체는 악성코드로 보기는 힘들지만, 무분별한 광고 팝업을 뜨게 하는 등의 악용 위험성으로 악성코드로 분류되기도 함.
4. Reflection Attack(반사공격) : 송신자가 생성한 메시지를 가로챈 공격자가 그 메시지를 다시 송신자에게 재전송하여 접근 권한을 얻는 형태의 공격 방법.


29. 공격기법
1. 핑 오브 데스: 시스템 공격 기법 중 하나로 허용범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시킨다. ICMP가 패킷을 많이 쏘니 핑 하고 죽어삣네. 
2. Session Hijacking(세션 가로채기) : 컴퓨터 시스템의 정보나 서비스에 무단으로 접근하기 위해 유효한 컴퓨터 세션(세션 키라고도 함)을 이용하는 것 일반적인 예로 두 컴퓨터 간에 활성화된 상태(즉, 로그인된 상태)에서 공격자가 피공격자의 로그인 정보를 활용하여 자신에게 필요한 행위를 하는 것을 뜻한다.
3.Piggyback Attack(피그백 공격) : 공격자가 다른 사용자의 연결에서 계정을 사용하지 않는 비활성 기간(비활성 간격)을 이용하여 시스템에 액세스(접근)한다. 이는 간선(회선 간) 공격이라고도 불린다.
-> 쉽게 설명하자면, 시스템에 대한 합법적인 권한을 가진 사용자가 시스템에 접근할 때, 활성화된 기간(직접 로그인 인증을 받아야 하는 상황)에는 접근 권한이 없는 공격자가 비활성화된 기간(합법적 사용자가 시스템에 접근 인증을 받은 상황)에 마치 사용자와 관련있는 사람인 듯이 태그를 붙여 몰래 뒤따라 들어가는 것이라 할 수 있다.
4.XSS (크로스 사이트 스크립팅) : 웹사이트에 악성 스크립트를 주입하는 행위. 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠를 삽입하거나, 피싱 공격을 진행하는 것.

30.
애자일 방법론 특징
소프트웨어 개발에 참여하는 구성원들 간의 의사소통 중시
환경 변화에 대한 즉시 대응
프로젝트 상황에 따른 주기적 조정 

* 각 단계의 결과가 완전히 확인된 후 다음 단계 진행  : 폭포수 모형 특징 

31.
대칭 암호 알고리즘과 비대칭 암호 알고리즘
     
     1.	대칭 암호 알고리즘은 비교적 실행 속도가 빠르기 때문에 다양한 암호의 핵심 함수로 사용될 수 있다.
     3.	비대칭 암호 알고리즘은 자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다.
     4.	대표적인 대칭키 암호 알고리즘으로는 AES, IDEA 등이 있다.

*	
대칭 암호화 알고리즘은 키 교환이 필요하기 때문에 키를 교환하는 중 키가 탈취될 수 있다는 문제가 있다.
공개 암호화 방식에 비해 속도가 빠르다.  
   
32.
	<문제 해설>
(Role Based Access Control)
역할 기반 접근통제
권한이 있는 사용자들만 접근할 수 있는 보안 방법


DAC  임의접근통제  사용자또는 신분
MAC 강제접근통제.  미리 정해진 정책과 보안 등급


MAC (Mandatory Access Control)
- 강제 접근 통제
- 미리 정해진 자원의 보안 레벨과 사용자에게 허락된 접근 권한 비교

DAC (Discretionary Access Control)
- 임의적 접근통제
- 자원에 대한 접근을 사용자나 그룹의 신분에 따라 제한
- 자원의 소유권을 가진 사람이 다른 사람의 접근을 허용하거나 제한할 수 있음

RBAC (Role Based Access Control)
- 사용자 역할에 따른 접근 통제
- 개별적인 신분이 아니라 조직 내 그룹 / 역할에 따라 부여


33.
<문제 해설>
개발유형에 따라 조직형(Organic), 반분리형(Semi-Detached), 내장형(Embedded)으로 구분한다.
[해설작성자 : 코봉이]

<cocomo 모델>
보엠이 고안한 소프트웨어 개발비용 산정 방법.
man-month = 투입 노력
개발 유형에 따른 3종류 - organic, semidetached, embedded
(기본, 중간, 내장형 모드)

개발 유형에 따른 3종류 - organic, semidetached, embedded
(기본, 중간, 내장형 모드) -> (조직형,반분리형,내장형)

COCOMO 모형
- 원시 프로그램 규모(LOC)에 의한 비용 산정 기법
- 보헴(Boehm)이 제안
- 비교적 작은 규모의 프로젝트들을 통계 분석한 결과를 반영한 모델 -> 중소 규모 소프트웨어 프로젝트 비용 추정에 적합
- 비용 산정 결과는 Man-Month로 표현

소프트웨어 개발유형에 따른 분류
  조직형(Organic)
  - 5만 라인 이하
  - 사무 처리용, 업무용, 과학용 소프트웨어 개발에 적합

  반분리형(Semi-Detached)
  - 30만 라인 이하
  - 컴파일러, 인터프리터 개발에 적합

  내장형(Embedded)
  - 30만 라인 이상
  - 미사일 유도 시스템, 실시간 처리 시스템 개발에 적합

럼:프로젝트 개발유형에 따라 object, dynamic, function의 3가지 모드로 구분한다.


34.
Authentication
자신의 신원을 시스템에 증명하는 과정, 아이디와 패스워드를 입력하는 과정이 가장 일반적인 예시 

Authorization 인가
권한부여

