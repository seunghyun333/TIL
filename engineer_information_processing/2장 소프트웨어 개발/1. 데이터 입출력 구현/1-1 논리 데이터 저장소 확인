(1) 자료 구조
1. 개념 : 자료 구조는 컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조, 자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있게 하여 성능을 향상시킨다.
2. 자료 구조의 분류
    선형 구조: 데이터를 연속적으로 연결한 구조 / 리스트, 스택, 큐, 데크
    비선형 구조: 데이터 비연속적으로 연결한 자료 구조 / 트리, 그래프
3. 선형 구조
    -1 리스트(List)
        * 선형 리스트(Linear List) 
            - 배열과 같이 연속되는 기억 장소에 저장되는 리스트
            - 선형 리스트의 대표적인 구조로는 배열(Array)등이 있음
            - 가장 간편한 자료 구조이며, 접근 구조가 빠름
            - 자료의 삽입, 삭제 시 기존 자료의 이동이 필요
        * 연결 리스트(Linked List)
            - 노드의 포인터 부분으로 서로 연결시킨 리스트
            - 연결하는 방식에 따라 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트, 이중원형 연결 리스트로 구분
            - 노드의 삽입, 삭제가 선형 리스트와 달리 편리
            - 연결을 위한 포인터가 추가되어 저장 공간이 추가로 필요
            - 포인터를 통해 찾는 시간이 추가되어 선형 리스트에 비해 느림

    -2 스택(Stack)
        * 개념 : 한 방향으로만 자료를 넣고 꺼낼 수 있는 LIFO(Last In First Out)형식의 자료 구조, 
        * 구성도 : push와 pop을 이용하여 자료를 넣고 꺼내고, TOP: 스택에 가장 위에 있는 데이터로, 스택 포인터라고 불림
        * 스택 연산 : push(데이터를 차례대로 스택에 넣는 연산)/pop(스택에서 가장 위에 있는 데이터를 하나씩 꺼내는 연산)
        * 스택의 자료 삽입, 삭제 
            - 삽입 
                If Top = n Then
                    Overflow
                Else {
                    Top = Top + 1
                    insert S(Top)
                }
                => 스택에 데이터가 n개면 삽입할 공간이 없으므로 오버플로, n개가 아니면 스택 포인터 Top 값을 1 증가

            - 삭제
                If Top = 0 Then
                    Underflow
                Else {
                    remove S(Top)
                    Top = Top - 1
                }
            * 스택의 응용분야
                - 인터럽트의 처리 : 현재 진행중인 명령어를 스택에 push하고 인터럽트 상황을 처리한 후 pop을 통해 받아옴
                - 함수 호출 (=서브루틴호출)(재귀 호출 포함) : 함수를 호출 시 현재 진행 중인 명령어 주소를 스택에 저장
                - 후위표현 연산 : postfix를 계산할 때 사용
                - 깊이 우선 탐색 : 깊이 내려갈 때마다 스택에 값을 push하고, 더 이상 깊이 갈 곳이 없을 경우 스택에서 pop한 노드와 인접한 노드를 찾음 
    
    -3 큐
        * 개념 : 한쪽 끝에서 삽입 작업이 이뤄지고 반대쪽 끝에서는 삭제 작업이 이루어지는 FIFO(Fist In First Out)형식의 자료 구조 
        * 구성 : ENQUEUE (삽입), DEQUEUE(데이터 꺼내기), 데이터가 꺼내는 쪽에서 가장 가까운 데이터를 Head(Front), 넣는 쪽과 가까운 데이터를 Tail(Rear)
        
    -4 데크 (Deque)
        * 개념 : 큐의 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료구조이다. 
        * 구성도 : 두 개의 포인터를 사용하여 양쪽의 삭제/삽입이 가능하다, 데크를 이용한 스택과 큐의 구현이 가능하다 
        * 연산 : PUSH, POP

4. 비선형 구조
    -1 트리
        * 개념 : 데이트들을 계층화 시킨 자료 구조, 그래프의 특수한 형태로 노드와 선분으로 되어있고, 
                정점 사이에 사이클이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조이며,
                인덱스를 조작하는 방법으로 가장 많이 사용하는 구조이며, 트리는 노드와 노드를 연결하는 링크로 구성되며,
                배열과 달리 노드들이 포인터로 연결되어 노드의 상한선이 없다. 

                루트노드(레벨1), 부모노드(레벨2), 형제노드(레벨2), 자식노드(레벨3), 단말노드(레벨4)
        *용어 :
            루트 노드 - 트리에서 부모가 없는 최상위 노드, 트리의 시작점
            단말 노드 - 자식이 없는 노드, 트리의 가장 말단에 위치 
            레벨 - 루트 노드를 기준으로 특정 노드까지의 경로 길이
            조상 노드 - 특정 노드에서 루트에 이르는 경로상 모든 노드
            자식 노드 - 특정 노드에 연결된 다음 레벨의 노드 
            부모 노드 - 특정 노드에 연결된 이전 레벨의 노드
            형제 노드 - 같은 부모를 가진 노드
            깊이(Depth) - 루트 노드에서 특정 노드에 도달하기 위한 간선의 수 
            차수(Degree) - 특정 노드에 연결된 자식 노드의 수 
    
    -2 트리 순회 방법
        * 전위 순회 방법 : Root -> Left -> Right
        * 중위 순회 방법 : Left -> Root -> Right
        * 후위 순회 방법 : Left -> Right -> Root 

    -3 트리 종류
        * 이진 탐색 트리(Binary Search Tree)
            : 차수가 2 이하인 노드로 구성되어 자식이 둘 이하로 구성된 트리
            : 부모 노드보다 작은 값은 왼쪽으로 부모 노드보다 큰 값은 오른쪽 노드에 생성 
        * AVL 트리(Adelson-Velsky and Landis Tree)
            : AVL 트리는 두 자식 서브 트리의 높이는 항상 최대 1만큼 차이가 나도록 스스로 균형을 잡는 이진 탐색 트리 
        * 2-3트리
            : 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리
            : AVL 탐색 트리의 단점인 삽입과 삭제 시의 전체 트리를 재구성하는 부분을 줄인 트리
        * 레드-블랙 트리
            : 각 노드는 빨강 또는 검저의 색상을 가지고 있으며 색깔에 대한 규칙을 통해 스스로 균형을 잡는 이진 탐색 트리
            










* 노드
: 데이터 저장부분과 포인터 부분으로 구성된 저장 공간
* 수식 Infix -> prefix, Postfix로 변환하기
    Prefix : 계산 순서에 맞게 괄호를 친 후 기호들을 괄호 안에서 가장 앞쪽으로 옮긴 후 괄호 제거
    Postfix : 계산 순서에 맞게 괄호를 친 후 기호들을 괄호 안에서 가장 뒤쪽으로 옮긴 후 괄호 제거 

