(1) 알고리즘
1. 개념 : 어떠한 문제를 해결하기 위한 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 기법
2. 특성
    알고리즘의 표현은 자연어, 순서도, 의사 코드, 프로그래밍 언어를 이용하는 방법이 있으며, 따라서 프로그램이 언어가 아니더라도 알고리즘의 표현은 가능하다.
    *입력, 출력, 명확성, 유한성, 유효성
3. 기법 
* 분활과 정복 : 문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 다시 병합하여 문제의 답을 얻는 알고리즘
* 동적계획법 : 어떤 문제를 풀기위해 그 문제를 더 작은 무넺의 연장선으로 생각하고 과거에 구한 해를 화룡하는 방식의 알고리즘
* 탐욕법 : 결정을 해야할 때마다 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택함으로써 최종적인 해답에 도달하는 방식의 알고리즘
* 백트래킹 : 어떤 노드의 유망성 점검 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손노드를 검색하는 알고리즘 

4. 시간 복잡도에 :따른 알고리즘 분류
    해시함수, 이진탐색, 순차탐색, 퀵정렬, 합병 정렬, 힙 정렬, 거품 정렬, 삽입 정렬, 선택 정렬 
5. 알고리즘 설명 
    1. 해싱 함수 : 해싱 함수는 데이터를 키로 변환하는 함수, 예를 들어 길고 복잡한 문자열을 짧고 단순한 문자열로 변경하는 함수이다. 
        임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수 : 제산법, 제곱법, 숫자번석법, 폴딩법, 기수 변환법, 무작위 방법 
        해싱함수를 선택할 때 곗간과정의 단순화, 충돌의 최소화, 기억장소 낭비의 최소화, 오버플로우가 최소화를 고려해야한다. 
    2. 검색 알고리즘 
        가. 순차 검색 : 배열의 청므부터 끝까지 차례대로 비교하여 원하는 데이터를 찾아내는 알고리즘 
        나. 이진 검색 : 정렬도이ㅓ 있는리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 알고리즘, 효율이 좋고 시간이 적게 소요된다.
    3. 정렬 알고리즘 
        가. 퀵 정렬 : 피벗을 두고 피벗의 왼쪽에는 피벗보다 작은 값을 오른쪽에는 큰 값을 두는 과정을 반복하는 알고리즘 
                    레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다. 
        나. 합병 정렬 : 전체 원소를 하나의 단위로 분할한 후 분할한 원소를 다시 합병해서 정렬하는 알고리즘 
        다. 힙정렬 : 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 알고리즘       
                    완전이진 트리로 입력 자료의 레코드를 구성
        라. 거품 정렬 : 인접한 2개의 레코드 키값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 알고리즘 
                    한 PASS를 수행할 때마다 가장 큰 값이 맨 뒤로 이동하기 때문에 PASSfmf '요소의 개수-1'번 수행하게 되면 모든 숫자가 정렬된다. 
        마. 삽입 정렬 : 2번째 키와 첫 번째 키를 비교하여 순서대로 나열하고, 이어서 3번째 키를 1, 2번째 키와 비교해 순서대로 나열하고, 계속해서 n번째 키를 앞의 (n-1)개 키와 비교하여 알맞은 순서에 삽입하는 알고리즘
        바. 선택 정렬 : 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 알고리즘 


(2) 소스 코드 품질 분석
1. 개념 : 소스 코드에 대한 코딩 스타일, 설정된 코딩 표준, 코드의 복잡도, 코드 내에 존재하는 메모리 누수 현황, 스레드의 결함 등을 발견하기 위한 활동 
2. 유형 : 
        정적 분석 도구 : 작성된 소스 코드를 실행시키지 않고, 코드 자체만으로 코딩 표준 준수 여부, 코딩 스타일 적정 여부, 잔존 겷마 ㅂ라견 여부를 확인하는 코드 분석 도구
        동적 분석 도구 : 애플리케이션을 실행하여 코드에 존재하는 메모리 누수 현황을 발견하고, 발생한 스레드의 결함등을 분석하기 위한 도구 
3. 분석 도구 : 
    정적 분석 도구 : pmd / 자바 및 타 언어 소스 코드에 대한 버그, 데드 코드 분석 도구
                    cppcheck : C/C++ 코드에 대한 메모리 누수, 오버플로우 등 문제 분석 도구 
                SonarQube : 소스 코드 품질 통합 플랫폼, 플러그인 확장가능
                checkstyle: 자바 코드에 대한 코딩 표준 검사 도구
                ccm : 다양한 언어의 코드 복잡도 분석 도구, 리눅스 , 맥 환경 CLI 형태 지원
                cobertura : jcoverage 기반의 테스트 커버리지 측정 도구 
    동적 분석 도구 : Avalanche : Valgrind 프레임워크 및 STP 기반 소프트웨어 에러 및 취약점 동적 분석 도구
                 Valgrind : 자동화된 메몰 ㅣ및 스레드 결함 발견 분석 도구 
4. 소스 코드 복잡도 분석 
    - 1. 맥케이브 회전 복잡도 개념 : 소프트웨어의 제어 흐름을 그래프로 표현하고 소스코드의 복잡도를 정량적으로 나타내는 지표
    - 2. 맥케이브 회전 복잡도 특징 : 정량적 지표 , 구조적 평가, 간접 방식 
    - 3. 맥케이브 회전 복잡도 측정 방식 : 제어 흐름에 의한 그래프를 통하여 원시 코드의 회전수를 구하여 복잡도를 게산한다. 
        (*계산식 확인)


(3) 코드 최적화
1. 개념 : 읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것으로 소스 코드 품질을 위해 기본적으로 지킬 원칙과 기준을 정의하고 있다.
2. 클린코드
    -1. 개념 : 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드이다.
    -2. 특징 : 중복 코드 제거로 애플리케이션의 설계가 개선된다, 버그를 찾기 쉬워지며 프로그래밍 속도가 빨라진다.
    -3. 클린코드를 저해하는 배드 코드 : 다른 개발자가 로직을 이해하기 어렵게 작성된 코드.
        유형 : 오염, 문서부족, 의미없는이름, 높은 결합도, 아키텍처 침식, 외계인 코드, 스파게티 코드,알수없는 변수명, 로직 중복
    -4. 클린 코드 작성 원칙 : 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화
    -5. 클린 코드의 유형 : 의미있는 이름, 간결하고 명확한 주석, 보기좋은배치, 작은 함수, 읽기 쉬운 제어 흐름, 오류처리, 클래스 분할배치, 느슨한 결합 기법 적용, 코딩형식 기법 적용,