1. 소프트웨어 개발 방법론
[기출문제]
1. 절차보다는 사람이 중심이 되어 변화에 유연한 신속한 즉응적 경량 개발 방법론으로 개발기간이 짧고 최근 회사에서 각광받는 워터폴에 대비되는 방법론 : 애자일 방법론
2. LoC가 30,000라인이고, 개발자가 5명 이며, 개발자가 월평균 300라인을 개발할 때 
    프로젝트 개발 기간 : 30,000 / 300 / 5 = 20
3. 럼바우 모델링 
    1. 프로세스들의 자료 흐름을 중심으로 처리과정을 표현하는 모델링으로 자료 흐름도(DFD)를 활용하여 표현 : 기능 Functional Modeling
    2. 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서등의 동적인 행위를 표현하는 모델링으로 상태 다이어그램을 활용하여 표현 : 동적 Dynamic Modleing 
    3. 시스템에서 요구하는 객체를 찾고 객체 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링으로 객체 다이어그램을 활용하여 표현 : 객체 Object(=Informain) Modeling
4. 객체지향설계원칙 SOLID
    단일 책임의 원칙 SRP / 개방 폐쇠 원칙 OCP / 리스코프치환의 원칙 LSP (서브타입은 어디서나 자신의 상위클래스로 교체할 수 있어야한다.)
    인터페이스 분리의 원칙 ISP / 의존성 역전의 원칙 DIP 

[예상문제]
1. 요구사항의 변경이 어렵고 각 단계의 결과가 확인되어야 다음 단계로 넘어갈 수 있는 선형 순차적, 고전적 생명주기 모형은 무엇인가 ? 폭포수 모델
2. 소프트웨어 생명주기 모델 중에서 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정하는 단계는 ? 설계단계
3. 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후 다음단계로 넘어가는 모델 : 폭포수 모델 
4. 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론은 ? 구조적 방법론 
5. XP의 기본 원리
    1. 작성해야 하는 프로그램에 대한 테스트를 먼저 수행하고 이 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리 : 테스트 기반 개발 TDD
    2. 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 통해 시스템을 재구성한다는 원리 : Refactoring
    3. 매일 여러 번씩 소프트웨어를 통합화 빌드해야한다는 원리: CI
6. 애자일 방법론 중에서 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론은 ? 스크럼 
7. 다음이 설명하는 소프트웨어 비용산정 기법은 ? 
    소프트웨어 비용산정 기법 중 산정 요원과 조정자에 의해 산정하는 방법, 전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법
        => 델파이 기법 / 전문가 합의법 
8. 요구 기능을 증가시키는 인자별로 가중치를 부여하고 요인별 가중치를 합산하여 총 기능 점수를 계산하여 비용을 선정하는 방식은? 
    기능점수 FP
    비용산정방식
    / LoC : 소프트웨어 각 기능의 원시 코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측지를 구하고 이를 이용하여 비용을 산정하는 방식
    / Man Month : 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
    / COCOMO : 보헴이 제안한 모형으로 프로그램 규모에 따라 비용을 산정하는 방식 
    / 푸트남 Putnam : 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식
    / 기능점수 FP : 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식 
9. 일의 순서를 계획적으로 정리하기 위한 수렴기법으로 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법 : PERT
    일정 관리 기법 
    주 공정법 CPM : 여러 작업들의 수행 순서가 얽혀있는 프로젝트의 일정을 계산하는 기법
    PERT : 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치의 3점 추정 방식을 통해 일정을 관리하는 기법 
    중요 연쇄 프로젝트 관리 : 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법 
10. CPM 네트워크가 다음과 같을 때 임계 경로의 소요기일은 얼마인가?  - 가장 오래 걸리는 경로 
11. LoC가 50,000라인, 개발자 10명, 생산라인 250라인 
    ManMonth : 50,000 / 250 = 200
    개발기간 : 50,000 / 250 / 10 = 20개월

2. 현행 시스템 분석
[기출문제]
1. Observer : 한 객체가 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야한다.
    Template : 일 부분을 서브 클래스로 캡슐화, 상위클래스에는 추상 메서드를 통해 기능의 골격을 제공, 하위 클래스에는 세부 처리를 구체화하는 방식, 코드 양을 줄이고, 유지보수를 용이하게 
    Command : 실행될 기능을 캡슐화, 명령에 맞는 서브 클래스가 선택되어 실행되는 특징 
    State : 객체 상태를 캡슐화하여 클래스화
    Strategy :  알고리짐 군을 정의하고(추상클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
2. 기능적 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항 / 비기능적 요구사항 : 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항. 
3. 디자인 패턴 유형 : 생성, 구조, 행위 
4. 디자인 패턴의 종류 중 Factory Method 패턴은 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. 
5. 디자인 패턴 중 행위 패턴은 반복적으로 사용되는 객체들의 상호 작용을 패턴화한 것으로 클래스나 객체들이 상호 작용을 패턴화한 것으로 클래스나 객체들이 상호작용하는 방법, 알고리즘 등과 관련된 패턴.
    <Interpreter, Observer, Command, Iterator, Stragey, Visitor>
6. Bridge 패턴은 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴이다. 
    Observer 패턴은 한 객체의 상태과 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호 작용 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴.
7. 디자인 패턴 중 객체의 대리자를 이용하여 원래 객체의 작업을 대신 처리하는 패턴 : Proxy 
8. Singleton 패턴은 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴이다.
    Visitor 패턴은 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드느 패턴. 
            객체의 구조는 변경하지 않으면서 새로운 기능만 따로추가하거나 확장할 때 사용하는 디자인패턴. 

[예상문제]
1. 시스템의 비기능적인 속성으로 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리등을 표현한 뷰
    개발자, 시스템 통합자 관점 : 프로세스 뷰 
2. 시스템을 계층으로 구분하여 구성하는패턴으로, 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어지는 패턴은? => 계층화 패턴
3. 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업을 수행할 수 있는 패턴, 컴포넌트를 분리하여 코드의 효율적인 재사용을 가능하게 하고, 여러 개의 뷰가 있어야하는 대화형 애플리케이션 
    모델, 컨트롤러 뷰의 서브시스템으로 구조화하는 패너: MVC 패턴 
4. 전역 변수를 사용하지 않고 객체를 하나만 생성하도록하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하고  한 클래스에 한 객체만 존재하도록 제한하는 디자인패턴  => 싱글톤 패턴 
5. 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 
    하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴 : 팩토리 메서드 
6. 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현결과를 만들 수 있는 디자인 패턴: 빌더패턴
7. 알고리즘 군을 정의하고 같은 알고리즘을 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴
    => Strategy 패턴 
8. 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴 : Template Method 패턴
9. 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할 : 어댑터 패턴 
10. 기능적 요구사항, 비기능적 요구사항 
11. 요구사항 개발 단계 중에서 소프트웨어가 해결해야할 문제를 이해하고, 고객으로부터 제시되는 추상적 요구에 대해 관련정보를 식별하고, 수집 방법 결정, 수집된 요구사항을 구체적으로 표현하는 단계
     => 요구사항 도출 
12. 말을 꺼내기 쉬운 분위기로 만들어 회의 참석자들이 내놓은 아이디어들을 비판없이 수용할 수 있도록 하는회의 : 브레인스토밍 
13. 요구사항 명세 단계에서 사용자의 요구를 표한할 대 자연어를 기반으로 서술하는 기법 : 비정형 명세 기법  / 사용자의 요구를 표현할 때 수학적인 원리와 표기법으로 서술하는 기법: 정형 명세 기법
14. 소프트웨어 개발 프로세스의 시작인 소프트웨어의 요구사항을 분석하고 정의하는 단계에서 작성되는 최종산출물은 : 요구사항 명세서 
15. 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법 : 인스팩션
    검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 기법 : 워크스루 
