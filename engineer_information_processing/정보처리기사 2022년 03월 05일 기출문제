1. 자료흐름도 4가지 구성요소
- 처리 Process : 원
- 자료흐름 Data Flow : 화살표
- 자료저장소 Data Store : 평행선
- 단말 Terminal : 사각형

2. 소프트웨어 개발시 모델은 향후 개발될 시스템을 유추하기 위해서 하는 활동이며, 주로 시스템 개발자가 실행합니다.

3. 소프트웨어 아키텍처의 설계과정
설계목표설정 -시스템 타입 결정 - 아키텍처 패턴 적용 - 서브시스템 구체화 - 검토

4. 	
EAI(Enterprise Application Integration): 기업 응용 프로그램 통합으로 기업용 응용 프로그램의 구조적 통합 방안을 가리킴
FEP(Front-End Processor): 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 차지하는 시간을 줄여주는 프로그램이나 하드웨어
GPL(General Public License): 자유 소프트웨어 재단(OSF)에서 만든 자유 소프트웨어 라이선스
Duplexing: 이중화(데이터베이스의 회복 기법 중 가장 간단한 것)

5.
테스트 드라이브 - 단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요
테스트 스텁 - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
테스트 슈트 - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
테스트 케이스 - 사용자의 요구사항을 정확히 준수했는지 확인하기 위한 입력 값, 실행조건, 기대결과 등으로 만들어진 테스트 항목의 명세서

스텁(stub)은 하향식
드라이버(driver)는 상향식

6. 
큐 : FIFO, 한쪽에서 삽입과 삭제가 모두 이루어 짐
데크(Deque) : 선형 리스트의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조
스택: LIFO, 인터럽트 처리, 서브루틴 호출 작업 등에 응용된다.

7. 정형 기술 검토 FTR
제품 검토에만 집중하라
의제를 제한하여 진행하라
논쟁과 반박을 제한하라
문제영역을 정확히 표현하라
해결책이나 개선책에 대해서는 논하지 말라
참가자수를 제한하고 사전준비를 강요하라
자원과 시간 일정을 할당하라  
모든 검토자들을 위해 의미있는 훈련을 시행하라
검토자들은 사전에 작성한 메모들을 공유하라
검토의 과정과 결과를 재검토하라

8. 소프트웨어 패키징은 소비자 중심으로 진행한다.

9. 	자로 구조 분류
-비선형 구조 : 트리, 그래프
-선형 구조 : 스택, 큐, 데크, 리스트
-파일 구조 : 순차파일, 색인파일, 직접파일

10. 	NS-Chart(Nassi-Schneiderman Chart)
- 3가지 기본구조만으로 논리를 표현(표준화 가능)
- Flow Chart의 최대 단점인 화살표가 표시되지 않음
- 기본구조의 입구와 출구는 각 하나씩
- 전체적인 알고리즘을 일목요연하게 볼 수 있음
- = 박스 다이어그램, = Chapin Char

11. 화이트박스
화이트박스 테스트 검증 기준
1. 문장 검증 기준
2. 분기 검증 기준
3. 조건 검증기준
4. 분기/조건 기준

블랙박스 테스트의 종류
1. 동치(동등)분할 검사
2. 경계값 분석
3. 원인-효과 검사
4. 오류 예측 검사
5. 비교검사

화이트박스 테스트 종류
기초 경로 검사(Basic Path Testing)
조건 검사(Condition Testing)
루프 검사(Loop Testing)
데이터 흐름 검사(Data Flow Testing)

12.  ISO/IEC 25000
- SW 품질 평가 통합 모델
- SQuaRE로도 불림
- ISO/IEC 9126, ISO/IEC 12119, ISO/IEC 14598의 3개 표준을 통합한 모델

- 2500n : 개요 및 품질관리
- 2501n : 품질모델
- 2502n : 품질측정
- 2503n : 품질요구
- 2504n : 품질평가
- 2505n : 확장분야

13. 데이터베이스 물리적 설계 단계
o 어떤 인덱스를 만들 것인지에 대한 고려
o 성능 향상을 위한 개념 스키마의 변경 여부 검토
o 레코드의 크기
o 파일과 구조 저장을 위한 최소한의 공간
o 빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 고려사항
- 응답 시간
- 저장 공간의 효율화
- 트랜잭션 처리량

스키마의 평가 및 정제는 논리적 설계에서 실행된다.

14. 정규형
- 제1정규형 : 릴레이션에 속한 모든 속성의 도메인이 원자값으로만 구성되어 있으면 제 1 정규형에 속한다.
- 제2정규형 : 제1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2 정규형에 속한다.(부분 함수 종속 제거)
- 제3정규형 : 제2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제3 정규형에 속한다.
- BCNF(보이스/코드) 정규형 : 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스/코드 정규형에 속한다.
- 제4정규형 : BCNF 정규형을 만족하면서 함수 종속이 아닌 다치 종속을 제거해야 만족할 수 있다.
- 제5정규형 : 제4 정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거해야 만족할 수 있다.

정규화 단계 - 원부이 결다조
1. 원자화
2. 부분 함수 종속 제거
3. 이행 함수 종속 제거
BCNF. 결정자 함수 종속
4. 다치 종속성 제거
5NF 조인 종속성 제거

15. π이름σ학과='교육'(학생)
=> SELECT 이름 FROM 학생 WHERE 학과='교육';

거꾸로 풀면됨 문제에서 학생이 가장 뒤에 있음 - 맨 앞에 생각하는 from문에 삽입 from 학생 그럼 2 or 4 문제에서 학과 = 교육 이니까 2번 답

Select 연산의 표기형식: σ조건(릴레이션)
σ학과='교육'(학생)
의미 -> <학생> 릴레이션에서 '학과'가 '교육'인 튜플들을 추출해줘.

Project 연산의 표기형식: π속성리스트(릴레이션)
π이름
의미 -> '이름' 속성을 추출해줘.

16.
UNION ALL : 각 쿼리의 모든 결과를 포함한 합집합 (중복제거 안함)
UNION : 각 쿼리의 결과 합을 반환하는 합집합 (중복제거)

17. 분산 데이터베이스
분산 데이터베이스 주요 구성 요소는
전역, 분할, 할당, 지역 스키마가 있다.

구성요소는 분산처리기, 분산 데이터베이스, 통신 네트워크

분산 데이터베이스의 구성 요소 - '분산'
1) 분산 처리기
2) 분산 데이터베이스
3) 통신 네트워크
4) 분산 트랜잭션
분산 데이터베이스의 구조 - 전역, 분할(단편화), 할당, 지역 스키마

18. 데이터베이스 병행제어의 목적 
- 여러 사용자들의 데이터베이스 공동 사용을 최대화
- 사용자의 응답 시간 최소화
- 데이터베이스 시스템의 활용도 최대화
- 데이터베이스의 일관성 유지


19.
#include <stido.h>
#include <stdlib.h>
int main(int argc, char *argv[] {
  int arr[2][3]={1,2,3,4,5,6}
  int (*p)[3]=NULL;
  p=arr;
  printf("%d", ", *(p[0]+1) + *(p[1]+2));
  prinf("%d", *(*(p+1)+0) + *(*(p+1)+1));
  return 0;
}

	<문제 해설>
p[0]=arr[0] -> p[0]+1=arr[0][1]=2
p[1]=arr[1] -> p[1]+2=arr[1][2]=6 2+6=8

p=arr[0]의 주소 -> p+1=arr[1] -> *(*(p+1)+0)=arr[1][0]=4
위와 같은 계산으로 *(*(p+1)+1=arr[1][1]=5 4+5=9
-----

그림으로 그려보자
int arr[2][3] = {1,2,3,4,5,6};

int arr  [2][3] 를 좀 쉽게 봐볼까요?
int arr  [2]            [3]
         세로           가로
         세로가 2개    가로가 3개
          1  2  3
          4  5  6  이렇게 상상해 보고 좀더 자세히 구분해 보아요

            0          1           2
        0   1[0][0]    2[0][1]     3[0][2]    
        1   4[1][0]    5[1][1]     6[1][2]    

       p[0]+1 는    [0][1] 와 같다. [0][1]에 들어 있는 숫자는 '2'이다.
       p[1]+2 는    [1][2] 와 같다  [1][2]에 들어 있는 숫자는 '6'이다.  2+6 = 8
       *(*(p+1)+0는 [1][0] 와 같다  [1][0]에 들어 있는 숫자는 '4'이다.
       *(*(p+1)+1는 [1][1] 와 같다  [1][1]에 들어 있는 숫자는 '5'이다.  4+5=  9

20. C언어 연산자
1) || : OR 연산 - 둘 중 하나라도 참이면 1
2) && : AND 연산 - 둘 다 참이어야 1
3) ** : 거듭제곱
4) != : 부등(피연산자가 서로 다를 시 true)

21. IPv6 
16비트씩 8부분의 16진수로 표시
2의128승개의 주소를 표현할 수 있다.
등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다.
확장기능을 통해 보안기능을 제공한다.

22.
ARP : IP 네트워크 상에서 IP주소를 MAC주소로 변환하는 프로토콜

ICMP : IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하는 프로토콜
     	TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜
ARP : 호스트의 IP주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꾸는 역할을 하는 프로트콜
PPP : 점대점 데이터링크를 통해 3계층 프로토콜들을 캡슐화시켜 전송하는 프로토콜

ECP(Error Checking Protocol)는 없음

23. 내부단편화의 크기
문제에서 Best Fit을 물을 시 내부단편화가 제일 작은 보기를 찾으면 됨
1) 20KB - 17KB = 3KB
2) 16KB - 17KB = 불가
3) 8KB - 17KB = 불가
4) 40KB - 17KB = 23KB
따라서 1번이 정답

- First Fit: 들어갈 수 있는 첫 번째 공간에 넣음
- Best Fit: 내부 단편화(자투리)가 가장 적게 남는 공간에 넣음
- Worst Fit: 가장 큰 공간에 넣음


24. JAVA
public class App{
  static void rs(char a[]){
  for(int i =0; i <a.loength; i++)
    if(a[i] == 'B')
      a[i] = 'C';
    else if(i==a.length -1)
      a[i] = a[i-1];
        else a[i] = a[i+1];
}

static void pca(char a[]) {
  for(int i = 0; i <a.length; i++)
  System.out.print(a[i]);
  System.out.println();
}

public static void main(Stirng[] args) {
  char c[] = {'A', 'B', 'D','D','A','B','C'};
  rs(c);
  pca(c);
  }
}

 	<문제 해설>
rs(c)는 대충 a=c라고 생각하고 rs(char a[])=rs(char c[])
c의 문자열 크기는 7이므로 a.length=7

rs()는 i가 7미만일때까지 반복한다는 의미
{'A', 'B', 'D', 'D', 'A', 'B', 'C'} 에서 a[0]='A', a[1]='B' 이런식으로 이해하면되는데
rs 첫번째 if문은 a[i]의 값이'B'인 경우 그 값을 B에서 C로 바꾸라는 의미이고
rs 두번째 else if는 i=6일때 a[6]=a[5]로 바꾸라는 의미이고
rs 세번째 else 는 1, 2번째 if문에 충족되지 않는 나머지 경우는 다 a[i]=a[i+1]을 해주라는 의미

{'A', 'B', 'D', 'D', 'A', 'B', 'C'}에서
i=0 이면 A[0]를 A[1]로 변경해서 {'B', 'B', 'D', 'D', 'A', 'B', 'C'}
i=1 이면 값이 B이기 때문에 C로 변경 {'B', 'C', 'D', 'D', 'A', 'B', 'C'}
i=2 이면 A[2]를 A[3]으로 변경 {'B', 'C', 'D', 'D', 'A', 'B', 'C'} -똑같아서 그대로 방치
i=3 이면 A[3]를 A[4]로 변경 {'B', 'C', 'D', 'A', 'A', 'B', 'C'}
i=4 이면 A[4]를 A[5]로 변경 {'B', 'C', 'D', 'A', 'B', 'B', 'C'}
i=5 이면 값이 B이기 때문에 C로 변경 {'B', 'C', 'D', 'A', 'B', 'C', 'C'}
i=6 이면 A[6]를 A[5]로 변경 {'B', 'C', 'D', 'A', 'B', 'C', 'C'}
pca(c)로 와서 char a[] 그대로 출력
정답은 {'B', 'C', 'D', 'A', 'B', 'C', 'C'} = 2번
[해설작성자 : 영남이공대 소프트웨어콘텐츠과]

1. 치환하는 문제임으로 a[i] == 'B' 일때 C로 치환하는 부분이 2번째 C를 확인.  
2. 첫번째 치환값이 얼마인지만 확인하면 금방 풀립니다. else부분에 a[0] = a[1] 값이므로 B
3. 따라서 B로 시작하고 2번째 6번째가 C인걸 찾으면 금방 풀립니다
[해설작성자 : 벼락치기 ㅜㅜ]

25.
	3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?
 	<문제 해설>
[1]  (1)   [4]
  [2]        [1]
        [0]    [3]
[해설작성자 : 정처기 공부]

1
12
1 //
120
204
041
413 최종
[해설작성자 : 오하요하이]

1 > 1 > 1 > 1 > 2 > 0 > 4
    2   2   2   0   4   1
            0   4   1   3
[해설작성자 : 전자공학도]

request    1 2 1 0 4 1 3
page 1st   1 1 1 1 4 4 4
     2nd     2 2 2 2 1 1
     3rd       0 0 0 0 3
page-fault 0 0 X 0 0 0 0

답은 : 4 1 3
[해설작성자 : 절대포기하지말자]

26. C언어
int main(int argc, char *argv[]{
  char str1[20] = "KOREA";
  char str2[20] = "LOVE";
  char* p1 = NULL;
  char* p2 = NULL;
  p1 = str1;
  p2=str2;
  str1[2]=p2[2];
  str2[3] = p1[4];
  stcat(str1, str2);
  prinf("%c", *p(1+2));
  return 0;
}

	<문제 해설>
str1[1]=str2[2] => str1의 KOREA중 O가 V로 변경
str1= KVREA
str2[3]=str1[4] =>str2의 LOVE중 E가 A로 변경
str2=LOVA

p1+2= str1[2]= R
[해설작성자 : 영남이공대 소프트웨어콘텐츠과]

덧붙이자면
strcat(str1, str2);에 의해
str1 => "KVREALOVA"가 됩니다.
[해설작성자 : 현직]

char str1 [20] = KOREA
*20개의 칸이 있고, 맨앞에서부터 KOREA가 들어감
char str2 [20] = LOVE
*20개의 칸이 있고, 맨앞에서부터 LOVE가 들어감

p1=str1 (p1을 str1이라고 여김) p2=str2 (p2을 str2이라고 여김)

str1[1]=p2[2]
*p2(str2)의 2번째인 O를 str1(p1)의 1번째인 O에 삽입.
str1 = KVREA

str2[3]=p1[4]
*p1(str1)의 4번째 A를 str2(p2)의 3번째인 V에 삽입.
str2=LOVA

strcat에 의해 str2를 str1 뒤로 붙임.
KVREALOVE라는 값이 나옴.

여기서 p1+2(str1[2])를 구하면 2번째인 R.

**혹시나 해서 말하지만 첫칸은 1이 아니라, 0이에요.
[해설작성자 : 친절한 설명]

27. C언어
a < b + 2 && a << 1 <= b
 
연산자 우선순위 문제
a < (b+2) -> true
a<<1 = 00000001 (1) 에서 좌측시프트 00000010 (2)/ 2<=b = true
&& - and 연산은 둘다 참일결우 1을 반환
[해설작성자 : 1트에 합격했지롱]

C언어라는것을 한번더 체크

a<b+2&&a<<1<=b // && : 좌항(a<b+2)과 우항(a<<1<=b)이 모두 True(1)이면 True(1)이다. 추가사항 : false 는 0, True 는 1
이때 a=1, b=2 식에 대입하면
-> 1<2+2&&1<<1<=2
좌항 : 1<2+2 // 사칙연산을 먼저한다.
      따라서, 1<4 는 True(1)
우항 : 1<<1<=2 // <<n 는 n비트 만큼 왼쪽으로 이동하라는 뜻
              // 1을 binary(2진수)으로 변환하면 1(000000001)이다
              // 1을 <<1 해주면 01(00000010)이 된다
              // 10을 decimal(10진수)로 변환하면 2가된다.
     따라서, 2<=2 는 True(1)
다시 돌아와 본식에 대입해  1<4&&2<=2  면 True(1) 가 된다. 따라서 최종답은 2번
                     True  True

28. 	UNIX 시스템의 쉘(shell)의 주요 기능에 대한 설명이 아닌 것은?
     
     1.	사용자 명령을 해석하고 커널로 전달하는 기능을 제공한다.
     2.	반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다.
     3.	쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다.  => 커널의 기능 
     4.	초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다.


29. 블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것
블루버그: 블루투스 장비사이의 취약한 연결 관리를 악용한 공격
블루스나프(블루스나핑): 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람
블루재킹: 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것

*OPP(Obex Push Protocol)- 블루투스 장치끼리 인증 없이 정보를 간편하게 교환하기 위하여 개발됨

30. 	DoS(Denial of Service) 공격과 관련한 내용으로 틀린
1.	Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.
2.	Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다. == > 멀티캐스트 x, 브로드캐스트 0
3.	SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.
4.	Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다.

31. 리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?
파일 생성 권한 666에서 644를 빼면 022
umask는 UNIX에서 파일이나 디렉터리의 초기 권한을 설정할 때 사용하는 값으로 파일의 경우 666에서 umask를 뺀 값을, 디렉터리일 경우 777에서 umask를 뺀 값을 초기 접근 권한으로 갖습니다

32. 로그파일 
wtmp
- 성공한 로그인/로그아웃 정보를 담고 있는 로그파일
- var/log/wtmp에 위치
- last 명령어 사용
1,2,3 전부 없는 명령어이다.
이밖에 참고로
utmp
- 현재 로그인 사용자 상태 정보를 담고 있는 로그파일
btmp
- 실패한 로그인 정보를 담고 있는 로그파일
last log
- 마지막으로 성공한 로그인 정보를 담고있는 로그파일
[해설작성자 : 윤정훈]

33. 상향식 비용 산정 기법 중 LOC 기법 예측지
LOC 예측치를 구하기 위해서는 낙관치, 비관치, 기대치가 필요하다.
예측치 = (낙관치+비관치+기대치*4)/6

34.
- PLCP(Physical Layer Convergence Procedure : 물리계층 수렴 처리)
    - 논리적인 802.11 MAC 부계층과 물리적인 특성을 연결하는 역할
    - 802.11 MAC 부계층이 물리적 특성에 관계없이 동작하도록 함
- Traffic Distributor
    - 네트워크 통신 간에 트래픽을 분배해주는 솔루션
- DPI
    - 네트워크에서 전송되는 패킷의 헤더와 페이로드 내 정보를 분석하는 컨텐츠 내용 분석 기술
    - 네트워크 보안, 관리, 컨텐츠 관리 등이 목적

*단어의 정의를 몰라도 하나씩 뜯어보면 Deep(내부) Packet Inspection(분석)으로 유추 가능
